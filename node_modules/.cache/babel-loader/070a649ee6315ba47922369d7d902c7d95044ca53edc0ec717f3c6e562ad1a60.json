{"ast":null,"code":"import _objectSpread from \"C:/Users/Asus/quizapp-project/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { warning } from 'hey-listen';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { instantAnimationState } from '../utils/use-instant-transition-state.mjs';\nimport { createAcceleratedAnimation } from './waapi/create-accelerated-animation.mjs';\nimport { createInstantAnimation } from './create-instant-animation.mjs';\nimport { animate } from './legacy-popmotion/index.mjs';\nimport { inertia } from './legacy-popmotion/inertia.mjs';\nimport { getDefaultTransition } from './utils/default-transitions.mjs';\nimport { isAnimatable } from './utils/is-animatable.mjs';\nimport { getKeyframes } from './utils/keyframes.mjs';\nimport { getValueTransition, isTransitionDefined } from './utils/transitions.mjs';\nimport { supports } from './waapi/supports.mjs';\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nvar acceleratedValues = new Set([\"opacity\"]);\nvar createMotionValueAnimation = function createMotionValueAnimation(valueName, value, target) {\n  var transition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  return function (_onComplete) {\n    var valueTransition = getValueTransition(transition, valueName) || {};\n    /**\n     * Most transition values are currently completely overwritten by value-specific\n     * transitions. In the future it'd be nicer to blend these transitions. But for now\n     * delay actually does inherit from the root transition if not value-specific.\n     */\n    var delay = valueTransition.delay || transition.delay || 0;\n    /**\n     * Elapsed isn't a public transition option but can be passed through from\n     * optimized appear effects in milliseconds.\n     */\n    var _transition$elapsed = transition.elapsed,\n      elapsed = _transition$elapsed === void 0 ? 0 : _transition$elapsed;\n    elapsed = elapsed - secondsToMilliseconds(delay);\n    var keyframes = getKeyframes(value, valueName, target, valueTransition);\n    /**\n     * Check if we're able to animate between the start and end keyframes,\n     * and throw a warning if we're attempting to animate between one that's\n     * animatable and another that isn't.\n     */\n    var originKeyframe = keyframes[0];\n    var targetKeyframe = keyframes[keyframes.length - 1];\n    var isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n    var isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n    warning(isOriginAnimatable === isTargetAnimatable, \"You are trying to animate \".concat(valueName, \" from \\\"\").concat(originKeyframe, \"\\\" to \\\"\").concat(targetKeyframe, \"\\\". \").concat(originKeyframe, \" is not an animatable value - to enable this animation set \").concat(originKeyframe, \" to a value animatable to \").concat(targetKeyframe, \" via the `style` property.\"));\n    var options = _objectSpread(_objectSpread({\n      keyframes: keyframes,\n      velocity: value.getVelocity()\n    }, valueTransition), {}, {\n      elapsed: elapsed,\n      onUpdate: function onUpdate(v) {\n        value.set(v);\n        valueTransition.onUpdate && valueTransition.onUpdate(v);\n      },\n      onComplete: function onComplete() {\n        _onComplete();\n        valueTransition.onComplete && valueTransition.onComplete();\n      }\n    });\n    if (!isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === false) {\n      /**\n       * If we can't animate this value, or the global instant animation flag is set,\n       * or this is simply defined as an instant transition, return an instant transition.\n       */\n      return createInstantAnimation(options);\n    } else if (valueTransition.type === \"inertia\") {\n      /**\n       * If this is an inertia animation, we currently don't support pre-generating\n       * keyframes for this as such it must always run on the main thread.\n       */\n      var animation = inertia(options);\n      return function () {\n        return animation.stop();\n      };\n    }\n    /**\n     * If there's no transition defined for this value, we can generate\n     * unqiue transition settings for this value.\n     */\n    if (!isTransitionDefined(valueTransition)) {\n      options = _objectSpread(_objectSpread({}, options), getDefaultTransition(valueName, options));\n    }\n    /**\n     * Both WAAPI and our internal animation functions use durations\n     * as defined by milliseconds, while our external API defines them\n     * as seconds.\n     */\n    if (options.duration) {\n      options.duration = secondsToMilliseconds(options.duration);\n    }\n    if (options.repeatDelay) {\n      options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n    }\n    var visualElement = value.owner;\n    var element = visualElement && visualElement.current;\n    var canAccelerateAnimation = supports.waapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== \"mirror\" && options.damping !== 0 && visualElement && element instanceof HTMLElement && !visualElement.getProps().onUpdate;\n    if (canAccelerateAnimation) {\n      /**\n       * If this animation is capable of being run via WAAPI, then do so.\n       */\n      return createAcceleratedAnimation(value, valueName, options);\n    } else {\n      /**\n       * Otherwise, fall back to the main thread.\n       */\n      var _animation = animate(options);\n      return function () {\n        return _animation.stop();\n      };\n    }\n  };\n};\nexport { createMotionValueAnimation };","map":{"version":3,"names":["warning","secondsToMilliseconds","instantAnimationState","createAcceleratedAnimation","createInstantAnimation","animate","inertia","getDefaultTransition","isAnimatable","getKeyframes","getValueTransition","isTransitionDefined","supports","acceleratedValues","Set","createMotionValueAnimation","valueName","value","target","transition","arguments","length","undefined","onComplete","valueTransition","delay","_transition$elapsed","elapsed","keyframes","originKeyframe","targetKeyframe","isOriginAnimatable","isTargetAnimatable","concat","options","_objectSpread","velocity","getVelocity","onUpdate","v","set","current","type","animation","stop","duration","repeatDelay","visualElement","owner","element","canAccelerateAnimation","waapi","has","repeatType","damping","HTMLElement","getProps"],"sources":["C:/Users/Asus/quizapp-project/node_modules/framer-motion/dist/es/animation/index.mjs"],"sourcesContent":["import { warning } from 'hey-listen';\nimport { secondsToMilliseconds } from '../utils/time-conversion.mjs';\nimport { instantAnimationState } from '../utils/use-instant-transition-state.mjs';\nimport { createAcceleratedAnimation } from './waapi/create-accelerated-animation.mjs';\nimport { createInstantAnimation } from './create-instant-animation.mjs';\nimport { animate } from './legacy-popmotion/index.mjs';\nimport { inertia } from './legacy-popmotion/inertia.mjs';\nimport { getDefaultTransition } from './utils/default-transitions.mjs';\nimport { isAnimatable } from './utils/is-animatable.mjs';\nimport { getKeyframes } from './utils/keyframes.mjs';\nimport { getValueTransition, isTransitionDefined } from './utils/transitions.mjs';\nimport { supports } from './waapi/supports.mjs';\n\n/**\n * A list of values that can be hardware-accelerated.\n */\nconst acceleratedValues = new Set([\"opacity\"]);\nconst createMotionValueAnimation = (valueName, value, target, transition = {}) => {\n    return (onComplete) => {\n        const valueTransition = getValueTransition(transition, valueName) || {};\n        /**\n         * Most transition values are currently completely overwritten by value-specific\n         * transitions. In the future it'd be nicer to blend these transitions. But for now\n         * delay actually does inherit from the root transition if not value-specific.\n         */\n        const delay = valueTransition.delay || transition.delay || 0;\n        /**\n         * Elapsed isn't a public transition option but can be passed through from\n         * optimized appear effects in milliseconds.\n         */\n        let { elapsed = 0 } = transition;\n        elapsed = elapsed - secondsToMilliseconds(delay);\n        const keyframes = getKeyframes(value, valueName, target, valueTransition);\n        /**\n         * Check if we're able to animate between the start and end keyframes,\n         * and throw a warning if we're attempting to animate between one that's\n         * animatable and another that isn't.\n         */\n        const originKeyframe = keyframes[0];\n        const targetKeyframe = keyframes[keyframes.length - 1];\n        const isOriginAnimatable = isAnimatable(valueName, originKeyframe);\n        const isTargetAnimatable = isAnimatable(valueName, targetKeyframe);\n        warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from \"${originKeyframe}\" to \"${targetKeyframe}\". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \\`style\\` property.`);\n        let options = {\n            keyframes,\n            velocity: value.getVelocity(),\n            ...valueTransition,\n            elapsed,\n            onUpdate: (v) => {\n                value.set(v);\n                valueTransition.onUpdate && valueTransition.onUpdate(v);\n            },\n            onComplete: () => {\n                onComplete();\n                valueTransition.onComplete && valueTransition.onComplete();\n            },\n        };\n        if (!isOriginAnimatable ||\n            !isTargetAnimatable ||\n            instantAnimationState.current ||\n            valueTransition.type === false) {\n            /**\n             * If we can't animate this value, or the global instant animation flag is set,\n             * or this is simply defined as an instant transition, return an instant transition.\n             */\n            return createInstantAnimation(options);\n        }\n        else if (valueTransition.type === \"inertia\") {\n            /**\n             * If this is an inertia animation, we currently don't support pre-generating\n             * keyframes for this as such it must always run on the main thread.\n             */\n            const animation = inertia(options);\n            return () => animation.stop();\n        }\n        /**\n         * If there's no transition defined for this value, we can generate\n         * unqiue transition settings for this value.\n         */\n        if (!isTransitionDefined(valueTransition)) {\n            options = {\n                ...options,\n                ...getDefaultTransition(valueName, options),\n            };\n        }\n        /**\n         * Both WAAPI and our internal animation functions use durations\n         * as defined by milliseconds, while our external API defines them\n         * as seconds.\n         */\n        if (options.duration) {\n            options.duration = secondsToMilliseconds(options.duration);\n        }\n        if (options.repeatDelay) {\n            options.repeatDelay = secondsToMilliseconds(options.repeatDelay);\n        }\n        const visualElement = value.owner;\n        const element = visualElement && visualElement.current;\n        const canAccelerateAnimation = supports.waapi() &&\n            acceleratedValues.has(valueName) &&\n            !options.repeatDelay &&\n            options.repeatType !== \"mirror\" &&\n            options.damping !== 0 &&\n            visualElement &&\n            element instanceof HTMLElement &&\n            !visualElement.getProps().onUpdate;\n        if (canAccelerateAnimation) {\n            /**\n             * If this animation is capable of being run via WAAPI, then do so.\n             */\n            return createAcceleratedAnimation(value, valueName, options);\n        }\n        else {\n            /**\n             * Otherwise, fall back to the main thread.\n             */\n            const animation = animate(options);\n            return () => animation.stop();\n        }\n    };\n};\n\nexport { createMotionValueAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}